# ===========================================================================
# GITHUB PUBLIC MIRROR PIPELINE
# Sanitizes and syncs selected content to public GitHub repository
# ===========================================================================
# Uses: github-sync-runner image with pre-installed tools and configs
# Configs: /etc/gitleaks/gitleaks.toml, /etc/github-sync/replacements.txt
# Triggers: On every push to main
# Target: github.com/$GITHUB_REPO
# ===========================================================================

variables:
  GITHUB_SYNC_IMAGE: "registry.example.net/infrastructure/nl/production/github-sync-runner:latest"

.github_sync_base:
  image: $GITHUB_SYNC_IMAGE
  tags:
    - docker
  variables:
    GIT_STRATEGY: none

# ===========================================================================
# SYNC TO GITHUB
# ===========================================================================

sync_to_github:
  extends: .github_sync_base
  needs: []
  stage: deploy
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: never    # ← Add this line
    - if: '$CI_COMMIT_BRANCH == "main"'
  script:
    - |
      set -e
      echo "================================================"
      echo "GitHub Public Mirror - Sanitization Sync"
      echo "================================================"
      echo "Source: ${CI_REPOSITORY_URL}"
      echo "Target: github.com/${GITHUB_REPO}"
      echo "Image:  ${GITHUB_SYNC_IMAGE}"
      echo "================================================"
      
      echo "[1/6] Cloning source repository..."
      git clone "${CI_REPOSITORY_URL}" repo
      cd repo
      
      # Fetching ansible from common repo
      echo "[1.5/6] Fetching ansible from common repo..."
      git clone "https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.example.net/infrastructure/common/production.git" /tmp/common
      cp -r /tmp/common/ansible/playbooks/* ansible/playbooks/ 2>/dev/null || mkdir -p ansible/playbooks && cp -r /tmp/common/ansible/playbooks/* ansible/playbooks/
      rm -rf /tmp/common
      git add ansible/playbooks/
      git commit -m "Add playbooks from common repo" || true

      echo "[2/6] Filtering to public paths..."
      git filter-repo --force \
        --path README.md \
        --path LICENSE \
        --path atlantis.yaml \
        --path renovate.json \
        --path k8s/ \
        --path network/configs/ \
        --path network/scripts/ \
        --path ansible/playbooks/ \
        --path ci/cisco.yml \
        --path ci/docker.yml \
        --path ci/k8s.yml \
        --path ci/github-sync.yml \
        --path docker/nl-matrix01/matrix/
      
      echo "[3/6] Applying static sanitization patterns..."
      echo "Using: /etc/github-sync/replacements.txt"
      git filter-repo --force --replace-text /etc/github-sync/replacements.txt
      
      echo "[4/6] Scanning and sanitizing secrets (multi-pass, multi-tool)..."
      echo "Using: /etc/gitleaks/gitleaks.toml"
      
      PASS=1
      MAX_PASSES=10
      while [ $PASS -le $MAX_PASSES ]; do
        echo ""
        echo "--- Secret scan pass $PASS of $MAX_PASSES ---"
        
        # Scan with gitleaks using image's config
        rm -f /tmp/leaks.json
        gitleaks detect --source . --no-git --config /etc/gitleaks/gitleaks.toml --report-format json --report-path /tmp/leaks.json 2>/dev/null || true
        
        # Also scan with trufflehog for entropy-based detection
        rm -f /tmp/trufflehog.json
        trufflehog filesystem . --no-update --json 2>/dev/null | jq -s '.' > /tmp/trufflehog.json || true
        
        # Merge findings
        rm -f /tmp/all_secrets.txt
        touch /tmp/all_secrets.txt
        
        # Extract gitleaks findings
        if [ -f /tmp/leaks.json ] && [ -s /tmp/leaks.json ] && [ "$(cat /tmp/leaks.json)" != "[]" ]; then
          cat /tmp/leaks.json | jq -r '.[].Secret // empty' >> /tmp/all_secrets.txt
        fi
        
        # Extract trufflehog findings
        if [ -f /tmp/trufflehog.json ] && [ -s /tmp/trufflehog.json ] && [ "$(cat /tmp/trufflehog.json)" != "[]" ]; then
          cat /tmp/trufflehog.json | jq -r '.[].Raw // empty' >> /tmp/all_secrets.txt
        fi
        
        # Deduplicate and filter
        sort -u /tmp/all_secrets.txt > /tmp/unique_secrets.txt
        
        # Check if any secrets found
        if [ ! -s /tmp/unique_secrets.txt ]; then
          echo "✅ No secrets found - repository is clean!"
          break
        fi
        
        SECRET_COUNT=$(wc -l < /tmp/unique_secrets.txt)
        echo "Found $SECRET_COUNT potential secrets"
        
        # Generate replacements (skip already redacted)
        rm -f /tmp/dynamic_replacements.txt
        touch /tmp/dynamic_replacements.txt
        
        while read -r secret; do
          # Skip already redacted, short strings, empty
          if [ -n "$secret" ] && [ ${#secret} -gt 8 ] && ! echo "$secret" | grep -qE "^REDACTED_"; then
            HASH=$(echo -n "$secret" | md5sum | cut -c1-8)
            echo "${secret}==>REDACTED_${HASH}" >> /tmp/dynamic_replacements.txt
            echo "  Redacting: ${secret:0:8}... (${#secret} chars) -> REDACTED_${HASH}"
          fi
        done < /tmp/unique_secrets.txt
        
        # Check if we generated any NEW replacements
        if [ ! -s /tmp/dynamic_replacements.txt ]; then
          echo "✅ Only false positives remain (already redacted strings)"
          break
        fi
        
        # Apply the replacements
        REPL_COUNT=$(wc -l < /tmp/dynamic_replacements.txt)
        echo "Applying $REPL_COUNT replacements via git-filter-repo..."
        git filter-repo --force --replace-text /tmp/dynamic_replacements.txt
        
        PASS=$((PASS + 1))
      done
      
      if [ $PASS -gt $MAX_PASSES ]; then
        echo "⚠️ Reached max passes ($MAX_PASSES) - some secrets may remain"
      fi
      
      echo ""
      echo "[5/6] Reorganizing structure..."
      git filter-repo --force --path-rename k8s/:kubernetes/
      git filter-repo --force --path-rename docker/nl-matrix01/:docker/matrix/
      
      echo ""
      echo "[6/6] Final verification and push..."
      
      # Final scan - only report non-redacted secrets
      rm -f /tmp/final_leaks.json
      gitleaks detect --source . --no-git --config /etc/gitleaks/gitleaks.toml --report-format json --report-path /tmp/final_leaks.json 2>/dev/null || true
      
      if [ -f /tmp/final_leaks.json ] && [ -s /tmp/final_leaks.json ] && [ "$(cat /tmp/final_leaks.json)" != "[]" ]; then
        # Filter out already redacted false positives
        REAL_LEAKS=$(cat /tmp/final_leaks.json | jq '[.[] | select(.Secret | startswith("REDACTED_") | not)]')
        REAL_COUNT=$(echo "$REAL_LEAKS" | jq 'length')
        
        if [ "$REAL_COUNT" -gt 0 ]; then
          echo "⚠️ Warning: $REAL_COUNT potential secrets still detected after sanitization"
          echo "Details:"
          echo "$REAL_LEAKS" | jq -r '.[] | "  - \(.RuleID): \(.File):\(.StartLine) - \(.Secret[0:20])..."'
          echo ""
          echo "These may be false positives. Review GitHub after sync."
        else
          echo "✅ Final scan clean - only redacted placeholders detected (expected)"
        fi
      else
        echo "✅ Final scan clean - no secrets detected!"
      fi
      
      echo ""
      echo "Pushing to GitHub..."
      git remote add github "https://${GITHUB_TOKEN}@github.com/${GITHUB_REPO}.git"
      git push github main --force
      
      echo ""
      echo "================================================"
      echo "✅ SUCCESS: https://github.com/${GITHUB_REPO}"
      echo "================================================"
  environment:
    name: github-public
    url: https://github.com/$GITHUB_REPO

# ===========================================================================
# DRY RUN - Test without pushing
# ===========================================================================

github_sync_dry_run:
  extends: .github_sync_base
  needs: []
  stage: validate
  rules:
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: manual
      allow_failure: true
  script:
    - |
      set -e
      echo "================================================"
      echo "GitHub Sync - DRY RUN (no push)"
      echo "================================================"
      echo "Using configs from image:"
      echo "  - /etc/gitleaks/gitleaks.toml"
      echo "  - /etc/github-sync/replacements.txt"
      echo "================================================"
      
      git clone "${CI_REPOSITORY_URL}" repo
      cd repo
      
      echo "[1/4] Filtering paths..."
      git filter-repo --force \
        --path README.md \
        --path LICENSE \
        --path atlantis.yaml \
        --path renovate.json \
        --path k8s/ \
        --path network/configs/ \
        --path network/scripts/ \
        --path ansible/playbooks/ \
        --path ci/cisco.yml \
        --path ci/docker.yml \
        --path ci/k8s.yml \
        --path ci/github-sync.yml \
        --path docker/nl-matrix01/matrix/
      
      echo ""
      echo "[2/4] Pre-sanitization scan..."
      gitleaks detect --source . --no-git --config /etc/gitleaks/gitleaks.toml --report-format json --report-path /tmp/pre_leaks.json 2>/dev/null || true
      if [ -f /tmp/pre_leaks.json ] && [ "$(cat /tmp/pre_leaks.json)" != "[]" ]; then
        PRE_COUNT=$(cat /tmp/pre_leaks.json | jq 'length')
        echo "Found $PRE_COUNT secrets before sanitization:"
        cat /tmp/pre_leaks.json | jq -r '.[] | "  - \(.RuleID): \(.File):\(.StartLine)"'
      else
        echo "No secrets found before sanitization"
      fi
      
      echo ""
      echo "[3/4] Applying sanitization (static + dynamic)..."
      git filter-repo --force --replace-text /etc/github-sync/replacements.txt
      
      # Multi-pass dynamic sanitization
      PASS=1
      MAX_PASSES=10
      while [ $PASS -le $MAX_PASSES ]; do
        rm -f /tmp/leaks.json /tmp/trufflehog.json /tmp/all_secrets.txt
        touch /tmp/all_secrets.txt
        
        gitleaks detect --source . --no-git --config /etc/gitleaks/gitleaks.toml --report-format json --report-path /tmp/leaks.json 2>/dev/null || true
        trufflehog filesystem . --no-update --json 2>/dev/null | jq -s '.' > /tmp/trufflehog.json || true
        
        if [ -f /tmp/leaks.json ] && [ -s /tmp/leaks.json ] && [ "$(cat /tmp/leaks.json)" != "[]" ]; then
          cat /tmp/leaks.json | jq -r '.[].Secret // empty' >> /tmp/all_secrets.txt
        fi
        if [ -f /tmp/trufflehog.json ] && [ -s /tmp/trufflehog.json ] && [ "$(cat /tmp/trufflehog.json)" != "[]" ]; then
          cat /tmp/trufflehog.json | jq -r '.[].Raw // empty' >> /tmp/all_secrets.txt
        fi
        
        sort -u /tmp/all_secrets.txt > /tmp/unique_secrets.txt
        
        if [ ! -s /tmp/unique_secrets.txt ]; then
          echo "Pass $PASS: Clean"
          break
        fi
        
        LEAK_COUNT=$(wc -l < /tmp/unique_secrets.txt)
        echo "Pass $PASS: Found $LEAK_COUNT potential secrets"
        
        rm -f /tmp/dynamic_replacements.txt
        touch /tmp/dynamic_replacements.txt
        
        while read -r secret; do
          if [ -n "$secret" ] && [ ${#secret} -gt 8 ] && ! echo "$secret" | grep -qE "^REDACTED_"; then
            HASH=$(echo -n "$secret" | md5sum | cut -c1-8)
            echo "${secret}==>REDACTED_${HASH}" >> /tmp/dynamic_replacements.txt
            echo "  Redacting: ${secret:0:8}... -> REDACTED_${HASH}"
          fi
        done < /tmp/unique_secrets.txt
        
        if [ ! -s /tmp/dynamic_replacements.txt ]; then
          echo "Pass $PASS: Only false positives remain"
          break
        fi
        
        git filter-repo --force --replace-text /tmp/dynamic_replacements.txt
        PASS=$((PASS + 1))
      done
      
      git filter-repo --force --path-rename k8s/:kubernetes/
      git filter-repo --force --path-rename docker/nl-matrix01/:docker/matrix/
      
      echo ""
      echo "[4/4] Post-sanitization scan..."
      gitleaks detect --source . --no-git --config /etc/gitleaks/gitleaks.toml --report-format json --report-path /tmp/post_leaks.json 2>/dev/null || true
      if [ -f /tmp/post_leaks.json ] && [ "$(cat /tmp/post_leaks.json)" != "[]" ]; then
        REAL_LEAKS=$(cat /tmp/post_leaks.json | jq '[.[] | select(.Secret | startswith("REDACTED_") | not)]')
        REAL_COUNT=$(echo "$REAL_LEAKS" | jq 'length')
        
        if [ "$REAL_COUNT" -gt 0 ]; then
          echo "⚠️ $REAL_COUNT real secrets remain after sanitization:"
          echo "$REAL_LEAKS" | jq -r '.[] | "  - \(.RuleID): \(.File):\(.StartLine) - \(.Secret[0:20])..."'
        else
          echo "✅ All real secrets sanitized! (Only REDACTED_ placeholders remain)"
        fi
      else
        echo "✅ All secrets sanitized successfully!"
      fi
      
      echo ""
      echo "================================================"
      echo "DRY RUN COMPLETE - No push performed"
      echo "================================================"

# ===========================================================================
# BUILD THE RUNNER IMAGE
# ===========================================================================

build_github_sync_runner:
  stage: .pre
  image: docker:24
  services:
    - docker:24-dind
  tags:
    - docker
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - docker/nlgitlab01/github-sync-runner/**/*
      when: manual
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - |
      cd docker/nlgitlab01/github-sync-runner
      docker build -t $GITHUB_SYNC_IMAGE .
      docker push $GITHUB_SYNC_IMAGE
  environment:
    name: docker-registry
