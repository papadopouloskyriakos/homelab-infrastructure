#!/usr/bin/env python3
"""
Direct Deployment Script - Hierarchical Diff Application
Deploys configuration changes using Netmiko with proper parent/child context handling

This script applies hierarchical diffs generated by generate_diff.py to Cisco devices.
It handles both additions and deletions (via "no" commands) to achieve true declarative
configuration management where GitLab is the source of truth.

Usage: direct_deploy.py <device_type> <device_name> <diff_yaml>

Example: direct_deploy.py Switch nlsw01 artifacts/diffs/nlsw01_diff.yml
"""
import sys
import os
import json
import time
from pathlib import Path
from datetime import datetime
from netmiko import ConnectHandler

class DeploymentError(Exception):
    """Custom exception for deployment failures"""
    pass

def load_diff_file(diff_path):
    """
    Load and validate diff JSON file
    Returns: dict with diff_blocks
    """
    if not Path(diff_path).exists():
        raise DeploymentError(f"Diff file not found: {diff_path}")
    
    try:
        with open(diff_path) as f:
            diff_data = json.load(f)
        
        if not isinstance(diff_data, dict):
            raise DeploymentError("Invalid diff file format: not a dictionary")
        
        if 'diff_blocks' not in diff_data:
            raise DeploymentError("Invalid diff file: missing 'diff_blocks' key")
        
        return diff_data
    
    except json.JSONDecodeError as e:
        raise DeploymentError(f"Failed to parse JSON: {str(e)}")

def build_command_sequence(block):
    """
    Build command sequence from diff block with proper hierarchy
    
    Args:
        block: Dictionary with 'parents' and 'lines' keys
    
    Returns:
        List of commands to execute in order
    """
    parents = block.get('parents', [])
    lines = block.get('lines', [])
    
    if not lines:
        return []
    
    commands = []
    
    # Enter parent contexts (if any)
    commands.extend(parents)
    
    # Add configuration lines
    commands.extend(lines)
    
    # Exit parent contexts (important for proper config mode handling)
    # We need one "exit" per parent level to return to global config
    for _ in parents:
        commands.append("exit")
    
    return commands

def detect_command_errors(output):
    """
    Detect error indicators in command output
    
    Returns: (has_error, error_type, error_snippet)
    """
    error_patterns = [
        ('Invalid input', 'SYNTAX_ERROR'),
        ('Incomplete command', 'INCOMPLETE'),
        ('Ambiguous command', 'AMBIGUOUS'),
        ('% Error', 'GENERIC_ERROR'),
        ('Failed to', 'OPERATION_FAILED'),
        ('not allowed', 'NOT_ALLOWED'),
        ('cannot', 'CANNOT'),
        ('denied', 'DENIED'),
        ('unknown command', 'UNKNOWN'),
    ]
    
    output_lower = output.lower()
    
    for pattern, error_type in error_patterns:
        if pattern.lower() in output_lower:
            # Extract snippet around error
            lines = output.split('\n')
            for line in lines:
                if pattern.lower() in line.lower():
                    return True, error_type, line.strip()[:150]
    
    return False, None, None

def apply_configuration_block(conn, block, block_num, total_blocks, device_type):
    """
    Apply a single configuration block to device
    
    Args:
        conn: Netmiko connection object
        block: Diff block dictionary
        block_num: Current block number (for logging)
        total_blocks: Total number of blocks
        device_type: Device type (for specific handling)
    
    Returns:
        (success, output, error_msg)
    """
    description = block.get('description', f'Block {block_num}')
    parents = block.get('parents', [])
    lines = block.get('lines', [])
    
    # Build command sequence
    commands = build_command_sequence(block)
    
    if not commands:
        return True, "No commands to apply", None
    
    # Log what we're doing
    context = parents[0][:60] if parents else "[GLOBAL]"
    print(f"   [{block_num}/{total_blocks}] {description[:50]}")
    print(f"      Context: {context}")
    print(f"      Commands: {len(lines)}")
    
    # Show first few commands (for visibility)
    for i, line in enumerate(lines[:2], 1):
        print(f"        {i}. {line[:60]}")
    if len(lines) > 2:
        print(f"        ... and {len(lines) - 2} more")
    
    try:
        # Apply commands WITHOUT exiting config mode
        # (we stay in config mode for all blocks)
        output = conn.send_config_set(commands, exit_config_mode=False)
        
        # Check for errors
        has_error, error_type, error_snippet = detect_command_errors(output)
        
        if has_error:
            error_msg = f"{error_type}: {error_snippet}"
            print(f"      [FAILED] {error_msg[:70]}")
            return False, output, error_msg
        
        print(f"      [OK] Applied successfully")
        return True, output, None
        
    except Exception as e:
        error_msg = f"Exception: {str(e)}"
        print(f"      [FAILED] {error_msg[:70]}")
        return False, str(e), error_msg

def backup_running_config(conn, device_name, backup_type="pre"):
    """
    Backup device running configuration
    
    Args:
        conn: Netmiko connection
        device_name: Device hostname
        backup_type: "pre" or "post" deployment
    
    Returns:
        Path to backup file
    """
    running_config = conn.send_command("show running-config", read_timeout=120)
    
    timestamp = int(time.time())
    backup_file = f"backups/{device_name}_{backup_type}_deploy_{timestamp}.cfg"
    
    os.makedirs("backups", exist_ok=True)
    
    with open(backup_file, 'w') as f:
        f.write(f"! Backup: {device_name}\n")
        f.write(f"! Type: {backup_type}-deployment\n")
        f.write(f"! Timestamp: {datetime.now().isoformat()}\n")
        f.write(f"!\n")
        f.write(running_config)
    
    return backup_file

def save_configuration(conn, device_type):
    """
    Save running configuration to startup configuration
    
    Args:
        conn: Netmiko connection
        device_type: Device type (Firewall/Router/Switch)
    
    Returns:
        (success, output)
    """
    try:
        if device_type == 'Firewall':
            # Cisco ASA uses "write memory"
            output = conn.send_command_timing("write memory", read_timeout=90)
        else:
            # IOS devices
            output = conn.save_config()
        
        # Verify save was successful
        success_indicators = ['OK', '[OK]', 'building configuration']
        
        if any(indicator in output for indicator in success_indicators):
            return True, output
        else:
            return False, f"Unexpected save output: {output[:200]}"
    
    except Exception as e:
        return False, f"Save exception: {str(e)}"

def verify_device_connectivity(conn, device_name):
    """
    Verify device is responsive and accessible after deployment
    
    Returns:
        (success, status_message)
    """
    try:
        # Get device uptime/status
        version_output = conn.send_command("show version | include uptime", read_timeout=30)
        
        if version_output and len(version_output) > 0:
            return True, version_output.strip()
        else:
            return False, "No response from device"
    
    except Exception as e:
        return False, f"Connectivity check failed: {str(e)}"

def deploy_configuration(device_type, device_name, diff_yaml):
    """
    Main deployment function
    
    Returns:
        0 on success, 1 on failure
    """
    print("=" * 70)
    print(f"DIRECT DEPLOYMENT: {device_name}")
    print(f"Device Type: {device_type}")
    print(f"Diff File: {diff_yaml}")
    print("=" * 70)
    print()
    
    # Get credentials from environment
    username = os.getenv('CISCO_USER', 'kyriakosp')
    password = os.getenv('CISCO_PASSWORD')
    
    if not password:
        print("ERROR: CISCO_PASSWORD environment variable not set")
        return 1
    
    try:
        # [1/7] Load diff file
        print("[1/7] Loading deployment configuration...")
        diff_data = load_diff_file(diff_yaml)
        diff_blocks = diff_data.get('diff_blocks', [])
        
        if not diff_blocks:
            print("   INFO: No configuration changes to apply")
            print()
            print("=" * 70)
            print("SUCCESS: No changes needed")
            print("=" * 70)
            return 0
        
        print(f"   Loaded {len(diff_blocks)} configuration blocks")
        print()
        
        # Show deployment preview
        print("DEPLOYMENT PREVIEW:")
        print("-" * 70)
        
        for i, block in enumerate(diff_blocks, 1):
            parents = block.get('parents', [])
            lines = block.get('lines', [])
            desc = block.get('description', '')
            
            context = parents[0][:60] if parents else "[GLOBAL]"
            print(f"Block {i}: {desc[:50] if desc else 'Configuration change'}")
            print(f"  Context: {context}")
            print(f"  Commands: {len(lines)}")
            
            for line in lines[:3]:
                prefix = "  + " if not line.strip().startswith("no ") else "  - "
                print(f"    {prefix}{line[:62]}")
            
            if len(lines) > 3:
                print(f"    ... and {len(lines) - 3} more")
            print()
        
        print("-" * 70)
        print()
        
        # Determine Netmiko device type
        netmiko_type_map = {
            'Firewall': 'cisco_asa',
            'Router': 'cisco_ios',
            'Switch': 'cisco_ios',
            'Access-Point': 'cisco_ios',
        }
        
        device_type_netmiko = netmiko_type_map.get(device_type, 'cisco_ios')
        
        # [2/7] Connect to device
        print("[2/7] Connecting to device...")
        
        device_params = {
            'device_type': device_type_netmiko,
            'host': f"{device_name}.example.net",
            'username': username,
            'password': password,
            'timeout': 120,
            'session_log': f'artifacts/direct_deploy_{device_name}_session.log',
            'fast_cli': False,
            'read_timeout_override': 90,
        }
        
        conn = ConnectHandler(**device_params)
        print(f"   SUCCESS: Connected to {device_name}")
        
        # Verify hostname matches
        hostname_output = conn.send_command("show running-config | include hostname")
        if device_name not in hostname_output:
            print(f"   WARNING: Hostname mismatch detected")
            print(f"   Expected: {device_name}")
            print(f"   Got: {hostname_output.strip()}")
        
        print()
        
        # [3/7] Backup running config
        print("[3/7] Backing up current configuration...")
        backup_file = backup_running_config(conn, device_name, "pre")
        print(f"   SUCCESS: Backup saved to {backup_file}")
        print()
        
        # [4/7] Enter configuration mode
        print("[4/7] Entering configuration mode...")
        conn.config_mode()
        print("   SUCCESS: In configuration mode")
        print()
        
        # [5/7] Apply configuration blocks
        print("[5/7] Applying configuration changes...")
        print()
        
        failed_blocks = []
        applied_blocks = 0
        
        for i, block in enumerate(diff_blocks, 1):
            success, output, error_msg = apply_configuration_block(
                conn, block, i, len(diff_blocks), device_type
            )
            
            if success:
                applied_blocks += 1
            else:
                failed_blocks.append({
                    'block_num': i,
                    'description': block.get('description', f'Block {i}'),
                    'error': error_msg,
                    'output': output[:300]
                })
        
        print()
        
        # Exit configuration mode
        conn.exit_config_mode()
        
        # Check for failures
        if failed_blocks:
            print("=" * 70)
            print(f"ERROR: {len(failed_blocks)} block(s) failed to apply")
            print("=" * 70)
            print()
            
            for failed in failed_blocks:
                print(f"Block {failed['block_num']}: {failed['description']}")
                print(f"  Error: {failed['error']}")
                print(f"  Output preview: {failed['output'][:150]}")
                print()
            
            print(f"Applied: {applied_blocks}/{len(diff_blocks)} blocks")
            print()
            print("ROLLBACK REQUIRED")
            print(f"Restore from: {backup_file}")
            print(f"Session log: artifacts/direct_deploy_{device_name}_session.log")
            
            conn.disconnect()
            return 1
        
        # [6/7] Save configuration
        print("[6/7] Saving configuration to NVRAM...")
        
        save_success, save_output = save_configuration(conn, device_type)
        
        if save_success:
            print("   SUCCESS: Configuration saved to NVRAM")
        else:
            print(f"   WARNING: Save had unexpected output:")
            print(f"   {save_output[:200]}")
        
        print()
        
        # [7/7] Post-deployment verification
        print("[7/7] Post-deployment verification...")
        
        # Verify connectivity
        verify_success, status = verify_device_connectivity(conn, device_name)
        
        if verify_success:
            print(f"   Device status: {status}")
        else:
            print(f"   WARNING: {status}")
        
        # Save post-deployment backup
        post_backup_file = backup_running_config(conn, device_name, "post")
        print(f"   Post-deployment backup: {post_backup_file}")
        
        print()
        
        # Disconnect
        conn.disconnect()
        
        # Success summary
        print("=" * 70)
        print("SUCCESS: Deployment completed")
        print("=" * 70)
        print()
        print(f"Applied: {applied_blocks}/{len(diff_blocks)} configuration blocks")
        print(f"Pre-backup: {backup_file}")
        print(f"Post-backup: {post_backup_file}")
        print(f"Session log: artifacts/direct_deploy_{device_name}_session.log")
        print()
        
        return 0
    
    except DeploymentError as e:
        print()
        print("=" * 70)
        print("DEPLOYMENT ERROR")
        print("=" * 70)
        print(f"Error: {str(e)}")
        print()
        return 1
    
    except Exception as e:
        print()
        print("=" * 70)
        print("UNEXPECTED ERROR")
        print("=" * 70)
        print(f"Error: {str(e)}")
        print()
        print("Stack trace:")
        import traceback
        traceback.print_exc()
        print()
        return 1

def main():
    """Main entry point"""
    if len(sys.argv) != 4:
        print("Usage: direct_deploy.py <device_type> <device_name> <diff_yaml>")
        print()
        print("Arguments:")
        print("  device_type  - Device type (Router/Switch/Firewall/Access-Point)")
        print("  device_name  - Device hostname (e.g., nlsw01)")
        print("  diff_yaml    - Path to diff YAML file")
        print()
        print("Example:")
        print("  direct_deploy.py Switch nlsw01 artifacts/diffs/nlsw01_diff.yml")
        print()
        sys.exit(1)
    
    device_type = sys.argv[1]
    device_name = sys.argv[2]
    diff_yaml = sys.argv[3]
    
    # Validate device type
    valid_types = ['Router', 'Switch', 'Firewall', 'Access-Point']
    if device_type not in valid_types:
        print(f"ERROR: Invalid device type: {device_type}")
        print(f"Valid types: {', '.join(valid_types)}")
        sys.exit(1)
    
    # Run deployment
    exit_code = deploy_configuration(device_type, device_name, diff_yaml)
    sys.exit(exit_code)

if __name__ == "__main__":
    main()